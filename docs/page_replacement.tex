\documentclass{ctexart}

\newtheorem{theorem}{定理}[section]
\newtheorem{definition}{定义}[section]
\newtheorem{lemma}{引理}[section]
\newtheorem{proof}{证明}[section]

\title{页面置换算法}
\author{ljt12138}

\begin{document}
\maketitle

\section{概述}

在现代页式虚拟存储计算机，内存被看作是磁盘的缓存，操作系统通过将常用的虚拟内存页放入物理内存页帧中，将不常用虚拟内存页放入磁盘中来提供更大、更自动化的虚拟存储。实现这种机制的方式是缺页中断。当访问的页不在物理内存中时，MMU会触发缺页中断，操作系统根据一定条件将这个虚拟内存页加载到内存中来。如果内存已经没有多余的页帧空闲，就需要将一些页面换出以空出空间。

页面置换算法决定哪一个空闲页被换出。一个更加通用的问题可以被这样描述：给定一台支持$M$个逻辑页面、拥有$N$个页面大小的内存的机器，选择每次的置换页面使得总的置换次数最少。同样的问题也适用于高速缓存和磁盘缓存的情景，许多算法是通用的。

页面置换算法可以分为离线算法（offine）和在线算法（online）。离线算法是指整个访存序列已经预先给定，在这种情况下拥有线性时间复杂度的最优算法；在线算法是指访存序列是动态给出的，只有解决了上一次的置换问题才会给出下一次访存操作。很显然，真实情景下的页面置换算法必须是在线的。一般来说，评价在线算法的优劣可以用其竞争性分析（Competitive analysis）的方法。给定在线算法与离线下的最优答案的比的上界称为在线算法的竞争比（Competitive ratio）。竞争比越接近1，说明算法与最优算法越接近。

我们首先给出最优算法，再对于几种经典的算法分析其近似比，最后通过在一些例子下的模拟实现，说明现有算法的优势和不足之处，并提出一些优化的思路和方法。

\section{最优置换算法}

当访存序列已经预先给定时，一种简单的算法\texttt{FIF}（Further-in-future）可以在线性时间内给出最优的置换方案。\texttt{FIF}只在发生缺页且没有空闲页面时发生换出，且总会换出下一次访问时间最晚的页面。可以证明，对于任意的访存序列，\texttt{FIF}总可以最小化缺页的次数。

下面的证明基于调整法和分类讨论，说明了在第一次发生缺页和换出时，将换出的页面调整为下一次引用更晚的，总是可以构造出换出方案使得缺页次数不多于原先的方案。

定义$Miss(A, S)$表示某个时刻内存中页面的集合为$A$，在处理之后访存序列$S$时最小的缺页次数。先证明一个引理：如果$A,B$仅有一页不同，那么$Miss(A, S) \ge Miss(B, S)-1$。

\begin{proof}
  对访存序列长度$len=|S|$做归纳。
  \begin{itemize}
    \item 当$len=1$时是显然的。
    \item 假设$len=n$时成立，我们只需证明$len=n+1$时成立。设$A=\{other, a\}, B = \{other, b\}$，考虑第一次访存的情况：
      \begin{enumerate}
        \item 访问$other$中的内容，$A,B$均命中，根据归纳假设显然。
        \item 访问$a$，$A$命中，$B$发生缺页。我们可以按照OPT算法，将$B$中$b$换出，$a$换入。在这次访存之后$A'=B'$，从而$Miss(A', S')=Miss(B', S')$，那么有$Miss(A, S)\ge Miss(B, S)-1$。
        \item 访问$b$，$A$出现缺页，$B$命中。不妨设$A$换出了一页$p$并将$b$换入，那么这次缺页之后$A', B'$仅有一页不同：$A'=\{other-{p}, a, b\}, B '= \{other, b\}$，根据归纳假设，$Miss(A', S')\ge Miss(B', S')-1$，那么也有$Miss(A, S)\ge Miss(B, S)-1$。
      \end{enumerate}
  \end{itemize}
\end{proof}

现在我们证明，OPT算法总是最优的。

\begin{proof}
  不妨设$nextpos(a, S)$表示页面$a$下一次被访问的位置，$len=|S|$表示访存序列长度。对访存序列的长度$len$做归纳。
  \begin{itemize}
  \item 当$len=1$时是显然的。
  \item 假设$len=n$时成立，我们只需证明$len=n+1$时成立。考虑第一次访存的情况：
    \begin{enumerate}
    \item 未缺页，不发生换入换出，根据归纳假设显然。
    \item 发生缺页，设当前内存状态为$A$。若我们没有按照OPT算法将下一次访问最晚的页面换出，而是换出了另外一个页面$a$，则必有$b\in A$，满足$nextpos(a, S)<nextpos(b, S)$。我们只需说明这次如果换出$b$，答案不会更劣便可以说明OPT算法总是最优的。
      
     考虑在原先的方案中$b$在什么时候被换出。

     \begin{enumerate}
       \item $b$在$nextpos(a, S)$之前被换出，如果我们一开始换出的是$b$，而在这次换出$a$，并不会引起任何缺页或命中的变化。
       \item $b$在$nextpos(a, S)$时被换出，$a$被换入，内存状态$A\{other, b\}\to A'\{other, a\}$。如果我们第一次换出的是$b$，在$nextpos(a, S)$之前的缺页和命中并没有任何变化，而$nextpos(a, S)$时并不会发生缺页，且此时内存状态也为$A'$。因此调整后总的缺页次数严格小于之前。
       \item $b$在$nextpos(a, S)$之后被换出。考虑在$nextpos(a, S)$时发生了一次缺页且没有换出$b$，内存状态$A\{other, b\}\to A'\{other-\{p\}, b, a\}$。而如果我们一开始换出的是$b$，这一次没有发生缺页，且内存状态是$B\{other, a\}$。注意到$A'$和$B$只有一位不同，根据之前的引理，有$Miss(A')\ge Miss(B)-1$。而在第$nextpos(a)$次我们减少了一次缺页，因此总的缺页数：$Miss(Before)\ge (Miss(After)-1)+1=Miss(After)$。
     \end{enumerate}
    \end{enumerate}
  \end{itemize}
  至此我们说明了，OPT算法是最优的。
\end{proof}


\end{document}
